def test_tasks_exist_and_callables(self):
    """
    Verify the DAG contains the expected task_ids and that each task's
    python_callable is wired to the correct function.
    """

    # --- expected task_id -> callable mapping ---
    # NOTE: if your DAG uses a different id for the load task (e.g. "data_load_bq_bq"),
    # change the key below to match EXACTLY what your DAG defines.
    expected = {
        "run_time_variables":           self.mock_run_time,
        "dimc_pre_check":               self.mock_pre,
        "data_load_write_disposition":  self.mock_write,
        "data_load_task":               self.mock_load,   # <-- change to your actual task_id if different
        "dimc_post_check":              self.mock_post,
    }

    # --- gather actual ids from the DAG ---
    got_ids = {t.task_id for t in getattr(self.dag, "tasks", [])}
    exp_ids = set(expected.keys())

    # Helpful diff instead of a hard equal set comparison
    missing = exp_ids - got_ids
    extra   = got_ids - exp_ids
    self.assertTrue(
        not missing,
        f"Missing tasks: {sorted(missing)} ; Extra tasks present (ignored): {sorted(extra)} ; Got: {sorted(got_ids)}"
    )

    # --- verify each task is wired to the right callable ---
    for tid, expected_fn in expected.items():
        op = self.dag.get_task(tid)  # will raise if tid still wrong

        # Some DAGs wrap callables (partial/lambda). Accept identity OR name match.
        same_callable = (
            op.python_callable is expected_fn or
            getattr(op.python_callable, "__name__", None) ==
            getattr(expected_fn, "__name__", None)
        )
        self.assertTrue(
            same_callable,
            f"{tid} wired to wrong callable: got "
            f"{getattr(op.python_callable, '__name__', op.python_callable)} "
            f"expected {getattr(expected_fn, '__name__', expected_fn)}"
        )
